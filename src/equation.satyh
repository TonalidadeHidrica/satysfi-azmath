% versatyle/math/equation.satyh
%
% align や gather に相当するコマンド群．

@require: base/list-ext
@require: base/tuple
@import: util
@import: common/matrix
@import: common/counter
@import: common/param
@import: parens
@import: matrices

% 別行立て数式につけるメタ情報。
type labelmeta = (|
  tag: string option;
  label: string option;
  no-label-flag: bool;
  keep-page-flag: bool;
|)

type labelfmt = context -> labelmeta -> inline-boxes option

module AZMathEquation : sig

  type labelmeta

% パラメータ・カウンタ
  % 別行立て数式環境の途中で改ページを許可するか。
  val allow-display-break: bool AZMathParam.t
  % 別行立て数式同士の縦の余白。
  val vmargin-between-eqn: (context -> length) AZMathParam.t
  % タグが数式の下に潜った時、その数式とタグの間に空ける縦方向の余白。
  val vmargin-between-eqn-and-tag: (context -> length) AZMathParam.t
  % 数式とタグの間に最低限なければならない余白の大きさ。
  % これを確保できそうにない場合はタグが数式の下に潜る。
  val min-gap-between-eqn-and-tag: (context -> length) AZMathParam.t

  % TODO: 数式環境前後の余白を指定可能にする
  % val min-gap-after-eqn: (context -> length) AZMathParam.t
  % val min-gap-before-eqn: (context -> length) AZMathParam.t

  % 数式番号のカウンタ。
  val ctr : Counter.t

% 数式環境
  % 複数の式を中央揃えにする。
  direct +eqn-gather : [labelfmt?;math list;] block-cmd
  direct \eqn-gather : [labelfmt?;math list;] inline-cmd
  % マーカーを付けた位置で複数の式を揃える。
  direct +eqn-align  : [labelfmt?; math list;] block-cmd
  direct \eqn-align  : [labelfmt?; math list;] inline-cmd
  % 横並びになった複数の式を揃える。
  direct +eqn-alignat : [int; math list;] block-cmd
  direct \eqn-alignat : [int; math list;] inline-cmd

% 数式の埋め込み
  % 数式内部で \eqn-align
  direct \eqn-aligned : [math list;] math-cmd
  % 場合わけ
  direct \eqn-cases : [math list;] math-cmd

% ラベル指定
  % 数式に付ける相互参照用のラベルを指定する。組版上の tag も変えられる。
  direct \label : [string?; string] math-cmd
  % このコマンドが付いた行だけ tag を強制的に付けない。
  direct \notag : [] math-cmd
  % このコマンドが付いた数式行の直後での改ページを抑制する。
  direct \keeppage : [] math-cmd
  % \notag\keeppage と同効果。 To Be Continued...
  direct \tbc : [] math-cmd

  % \label コマンドがつかない限り、基本的にラベルを付けないフォーマット。
  val notag : labelfmt

end = struct

% convenient functions

  let ib-annotation ?:ht key =
    let ht = ht |> Option.from 0pt in
    inline-graphics 0pt 0pt 0pt (fun (x, y) -> (
      let () = register-destination key (x, y +' ht) in []
    ))

  let create-max-height-vphantom lst-ib inner =
    % inline-boxes のリストに対し，それらの最大の高さ/最大の深さを求め，
    % それらをそれぞれ高さ・深さにもつよう加工した inline-boxes を返す．
    % ただし， width は 0 とする．
    let maximum len1 len2 = if len1 >' len2 then len1 else len2 in
    let get-natural-height ib = let (_, h, _) = get-natural-metrics ib in h in
    let get-natural-depth  ib = let (_, _, d) = get-natural-metrics ib in d in
    let max-height = List.fold-right maximum 0pt (List.map get-natural-height lst-ib) in
    let max-depth = List.fold-right maximum 0pt (List.map get-natural-depth lst-ib) in

    let (w, _, _) = get-natural-metrics inner in
    inline-graphics 0pt max-height max-depth (fun (x, y) -> [
      draw-text (x -' w, y) inner
    ])

% parameter

  let allow-display-break = AZMathParam.make true
  let vmargin-between-eqn = AZMathParam.make (fun ctx -> (get-font-size ctx) *' 0.6)
  let vmargin-between-eqn-and-tag = AZMathParam.make (fun ctx -> (get-font-size ctx) *' 0.3)
  let min-gap-between-eqn-and-tag = AZMathParam.make (fun ctx -> 2pt)

% counter

  let ctr = Counter.make 0 []

% parameter for extracting meta information from math text

  % metadata を表すパラメータ。
  let param-label-meta = AZMathParam.make (|
    tag = None;
    label = None;
    no-label-flag = false;
    keep-page-flag = false;
  |)

  % metadata を更新するコマンドたち。
  % text-in-math を使わないとうまくいかない。
  let-math \notag =
    let mathf ctx =
      let eqn-meta = param-label-meta |> AZMathParam.get in
      let () =
        param-label-meta |> AZMathParam.set (|
          eqn-meta with
            no-label-flag = true;
        |)
      in
      ${}
    in
    text-in-math MathOrd (fun ctx -> embed-math ctx (mathf ctx))

  let-math \label ?:tagstr label =
    let mathf ctx =
      let eqn-meta = param-label-meta |> AZMathParam.get in
      let () =
        param-label-meta |> AZMathParam.set (|
          eqn-meta with
            tag = tagstr;
            label = Some(label)
        |)
      in
      ${}
    in
    text-in-math MathOrd (fun ctx -> embed-math ctx (mathf ctx))

  let-math \keeppage =
    let mathf ctx =
      let eqn-meta = param-label-meta |> AZMathParam.get in
      let () =
        param-label-meta |> AZMathParam.set (|
          eqn-meta with
            keep-page-flag = true;
        |)
      in
      ${}
    in
    text-in-math MathOrd (fun ctx -> embed-math ctx (mathf ctx))

  let-math \tbc = ${\notag\keeppage}

% labelfmt

  % label-format のデフォルト値。
  let default-labelfmt ctx label-meta =
    let tagstr = match label-meta#tag with
      | Some(tag) -> tag  % tag が指定されていたらそれを使う
      | None -> (  % デフォルトでは連番の数字
          let v = ctr |> Counter.inc in
          arabic v
      )
    in
    let ib-tag =
      let it = embed-string tagstr in
      read-inline ctx {(#it;)}
    in
    % 相互参照への登録
    let ib-ref = match label-meta#label with
      | None -> inline-nil
      | Some(label) ->
          let (_, ht, _) = get-natural-metrics ib-tag in
          let () = register-cross-reference (`eq:` ^ label ^ `:num`) tagstr in
          (ib-annotation ?:ht (`eq:` ^ label))
            ++ hook-page-break ( fun pbinfo _ ->
              register-cross-reference (`eq:` ^ label ^ `:page`) (arabic pbinfo#page-number)
            )
    in
    Some(ib-ref ++ ib-tag)

  let notag ctx label-meta =
    match label-meta#label with
    | None -> None
    | Some(_) -> default-labelfmt ctx label-meta

% +eqn-gather

  % embed-math を行いつつ、内部で設定された meta 情報を返す。
  let embed-math-and-get-meta ctx m =
    let ib = embed-math ctx m in
    let eqn-meta = param-label-meta |> AZMathParam.get in
    let () = param-label-meta |> AZMathParam.discard in  % 初期値に戻す
    (ib, eqn-meta)

  let align-math ctx meta ib-m =
    let (wid-ib, _, _) = get-natural-metrics ib-m in
    let wid-line = get-text-width ctx in
    let wid-before-eqn = (wid-line -' wid-ib) *' 0.5 in

    % 数式間の縦の余白を規定する
    let mgn = (AZMathParam.get vmargin-between-eqn) ctx in
    let ctx = ctx |> set-paragraph-margin mgn mgn in

      [
        % 上側は allow-display-break パラメータで改行を許すか指定。
        % 下側は \keeppage が付いているかどうかで改行を許すか既定。
        line-break (AZMathParam.get allow-display-break) (not meta#keep-page-flag) ctx (
          (inline-skip wid-before-eqn) ++ ib-m ++ (inline-skip wid-before-eqn)
        )
      ]

  % 数式とタグの inline-boxes を受け取り、 block-boxes のリストを返す。
  let align-math-tag ctx meta ib-m ib-tag =
    let (wid-ib, _, _) = get-natural-metrics ib-m in
    let (wid-tag, _, _) = get-natural-metrics ib-tag in
    let wid-line = get-text-width ctx in

    let wid-before-eqn = (wid-line -' wid-ib) *' 0.5 in
    let wid-space-bwn-eqn-tag = wid-before-eqn -' wid-tag in

    % 数式間の縦の余白を規定する
    let mgn = (AZMathParam.get vmargin-between-eqn) ctx in
    let min-gap = (AZMathParam.get min-gap-between-eqn-and-tag) ctx in
    let ctx = ctx |> set-paragraph-margin mgn mgn in

    if wid-space-bwn-eqn-tag >' min-gap then
      % 数式とタグがぶつからない場合
      [
        line-break (AZMathParam.get allow-display-break) true ctx (
          (inline-skip wid-before-eqn) ++ ib-m
            ++ (inline-skip wid-space-bwn-eqn-tag) ++ ib-tag
        )
      ]
    else
      % ぶつかる場合
      let mgn-mid = (AZMathParam.get vmargin-between-eqn-and-tag) ctx in
      [
        % 上側は allow-display-break パラメータで改行を許すか指定。
        % 下側はタグとの境目なので必ず false。
        line-break (AZMathParam.get allow-display-break) false
          (ctx |> set-paragraph-margin mgn mgn-mid) (
          (inline-skip wid-before-eqn) ++ ib-m ++ (inline-skip wid-before-eqn)
        );
        % 上側は数式との境目なので必ず false。
        % 下側は \keeppage が付いているかどうかで改行を許すか既定。
        line-break false (not meta#keep-page-flag) (ctx |> set-paragraph-margin mgn-mid mgn) (
          (inline-skip (wid-line -' wid-tag)) ++ ib-tag
        );
      ]

  let-block ctx +eqn-gather ?:labelfmt mlst =
    % labelfmt の unwrap
    let labelfmt = labelfmt |> Option.from default-labelfmt in

    % math list を (inline-boxes * labelmeta) list に変換
    let ib-meta-lst = mlst |> List.map (embed-math-and-get-meta ctx) in

    % 数式の inline-boxes とtag情報を受け取り、block-boxes を返す。
    let align-eqn-f ib-meta =
      let (ib-m, eqn-meta) = ib-meta in
      % タグの inline-boxes を取得
      if eqn-meta#no-label-flag then
        align-math ctx eqn-meta ib-m
      else
        match (labelfmt ctx eqn-meta) with
        | None -> align-math ctx eqn-meta ib-m
        | Some(ib-tag) -> align-math-tag ctx eqn-meta ib-m ib-tag
    in

    let bb-lst = ib-meta-lst |> List.map align-eqn-f |> List.concat in
    bb-lst |> List.fold-left (+++) block-nil

  let-inline ctx \eqn-gather ?:labelfmt mlst =
    let labelfmt = labelfmt |> Option.from default-labelfmt in
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+eqn-gather?:(labelfmt)(mlst);>)
        ++ omit-skip-after

% +eqn-align

  let-block ctx +eqn-align ?:labelfmt mlst =
    % labelfmt の unwrap
    let labelfmt = labelfmt |> Option.from default-labelfmt in

    % math list を2つずつ取って [[math; math]; [math; math]; ... ] の形にし、
    % (inline-boxes * inline-boxes * labelmeta) list に変換
    let embed-math-and-get-meta [m-left; m-right] =
      let space = space-between-maths ctx m-left m-right in
      let ib-left = match space with
        | Some(ib-space) -> (embed-math ctx m-left) ++ ib-space
        | None -> embed-math ctx m-left
      in
      let ib-right = embed-math ctx m-right in
      let eqn-meta = param-label-meta |> AZMathParam.get in
      let () = param-label-meta |> AZMathParam.discard in  % 初期値に戻す
      (ib-left, ib-right, eqn-meta)
    in
    let math-llst = AZTypeMatrix.from-list 2 ${} mlst |> AZTypeMatrix.to-llist in
    let ib-meta-lst = math-llst |> List.map embed-math-and-get-meta in

    % 左辺・右辺の式の最大値を計算
    let left-max-wid = ib-meta-lst
      |> List.map (fun (left, _, _) -> get-natural-width left)
      |> List.fold-left length-max 0pt
    in
    let right-max-wid = ib-meta-lst
      |> List.map (fun (_, right, _) -> get-natural-width right)
      |> List.fold-left length-max 0pt
    in
    % 数式左側の余白幅の最小値（最も左に長い数式が来る行の左にある余白の幅）を計算
    let wid-min-before-eqn = ((get-text-width ctx) -' (left-max-wid +' right-max-wid)) *' 0.5 in

    % (ib-left, ib-right, meta) を受け取り、揃えて block-boxes のリストを返す
    let align-eqn-f (ib-left, ib-right, meta) =
      let wid-ib-left = get-natural-width ib-left in
      let wid-ib-right = get-natural-width ib-right in
      let wid-before-eqn = wid-min-before-eqn +' (left-max-wid -' wid-ib-left) in
      let wid-after-eqn = wid-min-before-eqn +' (right-max-wid -' wid-ib-right) in

      % 数式間の縦の余白を規定する
      let mgn = (AZMathParam.get vmargin-between-eqn) ctx in
      let ctx = ctx |> set-paragraph-margin mgn mgn in

      let align-math =
        [
          % 上側は allow-display-break パラメータで改行を許すか指定。
          % 下側は \keeppage が付いているかどうかで改行を許すか既定。
          line-break (AZMathParam.get allow-display-break) (not meta#keep-page-flag) ctx (
            (inline-skip wid-before-eqn) ++ ib-left ++ ib-right ++ (inline-skip wid-after-eqn)
          )
        ]
      in

      let align-math-tag ib-tag =
        let wid-line = get-text-width ctx in
        let wid-tag = get-natural-width ib-tag in
        let wid-space-bwn-eqn-tag = wid-after-eqn -' wid-tag in
        let min-gap = (AZMathParam.get min-gap-between-eqn-and-tag) ctx in
        if wid-space-bwn-eqn-tag >' min-gap then
          % 数式とタグがぶつからない場合
          [
            line-break (AZMathParam.get allow-display-break) true ctx (
              (inline-skip wid-before-eqn) ++ ib-left ++ ib-right
                ++ (inline-skip wid-space-bwn-eqn-tag) ++ ib-tag
            )
          ]
        else
          % ぶつかる場合
          let mgn-mid = (AZMathParam.get vmargin-between-eqn-and-tag) ctx in
          [
            % 上側は allow-display-break パラメータで改行を許すか指定。
            % 下側はタグとの境目なので必ず false。
            line-break (AZMathParam.get allow-display-break) false
              (ctx |> set-paragraph-margin mgn mgn-mid) (
              (inline-skip wid-before-eqn) ++ ib-left ++ ib-right ++ (inline-skip wid-after-eqn)
            );
            % 上側は数式との境目なので必ず false。
            % 下側は \keeppage が付いているかどうかで改行を許すか既定。
            line-break false (not meta#keep-page-flag) (ctx |> set-paragraph-margin mgn-mid mgn) (
              (inline-skip (wid-line -' wid-tag)) ++ ib-tag
            );
          ]
      in

      if meta#no-label-flag then
        align-math
      else
        match (labelfmt ctx meta) with
        | None -> align-math
        | Some(ib-tag) -> align-math-tag ib-tag

    in

    let bb-lst = ib-meta-lst
      |> List.map align-eqn-f |> List.concat in
    bb-lst |> List.fold-left (+++) block-nil

  let-inline ctx \eqn-align ?:labelfmt mlst =
    let labelfmt = labelfmt |> Option.from default-labelfmt in
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+eqn-align?:(labelfmt)(mlst);>)
        ++ omit-skip-after

% +eqn-alignat

  let math-to-aligned-ib ctx idx m mprevopt mnextopt =
    let lengap = get-font-size ctx *' 2. in

    let ibm = embed-math ctx m in
    let ib =
      match mnextopt with
      | None -> ibm
      | Some(mnext) ->
          let ibspaceopt = space-between-maths ctx m mnext in
          ( match ibspaceopt with
            | None          -> ibm
            | Some(ibspace) -> ibm ++ ibspace
          )
    in

    if idx mod 2 == 0 then
      inline-fil ++ ib
    else
      match mnextopt with
      | None    -> ib ++ inline-fil
      | Some(_) -> ib ++ inline-fil ++ inline-skip lengap

  let-block ctx +eqn-alignat ncol mlst =

    let vlen = 4pt in

    let math-matrix = AZTypeMatrix.from-list (ncol * 2) ${} mlst in
    let ib-matrix = AZTypeMatrix.map-rowidx-adjacent (math-to-aligned-ib ctx) math-matrix in

    let cell-matrix =
      AZTypeMatrix.map (fun ib -> NormalCell((0pt, 0pt, vlen, vlen), ib)) ib-matrix
    in

    let rulef _ _ = [] in
    let ib-tabular = tabular (AZTypeMatrix.to-llist cell-matrix) rulef in

    let margin = get-font-size ctx *' 1.0 in
    let ctx-eqn = ctx |> set-paragraph-margin margin margin in
    line-break true true ctx-eqn (inline-fil ++ ib-tabular ++ inline-fil)

  let-inline ctx \eqn-alignat ncol mlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+eqn-alignat(ncol)(mlst);>)
        ++ omit-skip-after

% \eqn-aligned

  let-math \eqn-aligned mlst =
    let embedf ctx =
      let vlen = 4pt in

      let math-matrix = AZTypeMatrix.from-list 2 ${} mlst in
      let ib-matrix = AZTypeMatrix.map-rowidx-adjacent (math-to-aligned-ib ctx) math-matrix in

      let cell-matrix =
        AZTypeMatrix.map (fun ib -> NormalCell((0pt, 0pt, vlen, vlen), ib)) ib-matrix
      in

      let rulef _ _ = [] in
      let ib-tabular = tabular (AZTypeMatrix.to-llist cell-matrix) rulef in

      let margin = get-font-size ctx *' 1.0 in
      let ctx-eqn = ctx |> set-paragraph-margin margin margin in
      ib-tabular
    in
    text-in-math MathOrd embedf

% \eqn-cases

  let-math \eqn-cases mlst =
    let aligner i j ib =
      if j mod 2 == 0 then ib ++ inline-fil
      else inline-fil ++ ib
    in
    let mtx = AZMathMatrices.matrix-body aligner 2 mlst in
    math-paren AZMathParens.curly-bracket-l AZMathParens.empty-bracket-r mtx

end
